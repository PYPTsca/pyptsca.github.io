# 广东金融学院2024学年第1学期《计算机导论》A卷答案及解析

## 一、单项选择题（每小题1分，共20分）

|题号|答案|核心解析|相关知识点|
|---|---|---|---|
|1|D|计算机系统三层结构明确为：硬件层（底层物理基础）→操作系统层（中间管理层）→应用软件层（上层功能层），其余选项无对应层级定义|计算机系统层次结构|
|2|D|鼠标是标准输入设备（向计算机输入操作指令）；硬盘是存储设备，题目其余选项空缺，仅D符合输入设备定义|计算机输入/存储设备区分|
|3|A|存储速度排序：寄存器（CPU内置，最快）→高速缓存（cache）→主存（RAM）→闪存（外存，最慢）|计算机存储层次与速度|
|4|D|高级语言包括Python、C++、Java（接近人类自然语言），机器语言是二进制指令，属于低级语言|程序语言分类（低级vs高级）|
|5|B|操作系统是系统软件核心，负责管理全部硬件资源（CPU、内存等）和软件资源（程序、数据等），并非仅管理单一资源|操作系统核心功能|
|6|B|有符号整数符号位规则：0表示正数，1表示负数；-1是负数，故最高位（符号位）为1|有符号数表示规则|
|7|B|栈的核心访问规则是“后进先出（LIFO）”，如同叠盘子；先进先出是队列规则，随机/倒序访问非栈特性|数据结构：栈的访问规则|
|8|B|UDP（用户数据报协议）是TCP/IP模型中传输层的核心协议，与TCP并列，负责端到端数据传输|TCP/IP协议分层与核心协议|
|9|C|IP地址（IPv4）为4段点分十进制，每段0-255：A多1段（5段），B、D少1段（3段），仅C符合格式|IP地址格式规范|
|10|C|函数可递归调用自身（如求阶乘的递归函数）；A（支持嵌套调用）、B（可无返回值，默认None）、D（先定义后调用）均正确|Python函数特性（递归）|
|11|B|栈“后进先出”：1、2、3依次入栈后，可能出栈顺序：1→2→3（A）、3→2→1（D）、2→1→3（C）；B选项3出栈后，栈内剩1、2，只能2先出，无法1先出|栈的存取规则应用|
|12|C|读取文件需调用操作系统接口（系统调用），属于软件中断（由程序主动触发）；硬件中断由硬件触发，异常处理请求针对逻辑错误（如除0）|中断与系统调用的区分|
|13|A|域名顶级域含义：.com（商业机构）、.gov（政府）、.edu（教育）、.org（社会组织）|域名系统（DNS）顶级域定义|
|14|D|计算机四代核心标志：第四代以大规模/超大规模集成电路为核心|计算机发展历程|
|15|C|计算机底层（内存、CPU缓存等）所有数据均以二进制（0和1）形式存储，其他进制仅为人类可读表示|计算机数据存储本质|
|16|B|冯·诺依曼体系结构（存储程序+程序控制）是现代计算机的基础，被誉为“现代计算机之父”|现代计算机核心体系结构|
|17|D|PC（Program Counter）是程序计数器，功能是指向下一步要执行的指令地址；通用寄存器存储临时数据，指令寄存器存储当前指令|CPU核心寄存器功能|
|18|D|衡量算法计算效率的核心指标是时间复杂度（执行所需时间资源），空间复杂度衡量内存占用|算法复杂度的核心维度|
|19|B|continue语句的作用是“终止本次循环，直接进入下一次循环”；终止循环用break，终止函数用return|Python关键字（continue）功能|
|20|C|目前互联网广泛采用的核心协议是TCP/IP协议簇；OSI是理论模型，电路交换是传统通信方式，以太网是链路层协议|互联网核心协议|

## 二、判断题（每小题1分，共10分）

|题号|答案|解析|
|---|---|---|
|1|×|8位有符号二进制数的最大正整数是2⁷-1=127；2⁸-1=255是8位无符号二进制数的最大取值|
|2|×|冰箱中的计算机是为特定控制任务（如温度调节）设计的**专用计算机**，并非通用计算机（可处理多种任务）|
|3|√|有符号整数正负数相加本质是“绝对值相减”，结果绝对值不会超过任一操作数，不会超出有符号数取值范围（如8位补码-128~127），故无溢出|
|4|√|CPU的核心组成是**运算器（又称计算器，执行算术/逻辑运算）** 和**控制器（协调各部件工作）**|
|5|×|CPU内部处理和存储数据的唯一形式是二进制，八进制、十六进制仅用于人类编写程序时的简化表示|
|6|√|Python列表是动态类型容器，支持存储不同类型元素（如`[1, "a", True]`）|
|7|√|FTP（文件传输协议）属于TCP/IP模型的应用层，负责文件上传与下载|
|8|×|计算机中有符号数**通常采用补码**（简化减法、统一0的表示），但并非“都采用”，早期曾使用原码、反码|
|9|√|除0异常是程序运行时的逻辑错误，属于**软件中断**（由程序触发，需操作系统处理）|
|10|×|用户态下的应用程序不能直接访问硬盘等硬件，需通过系统调用（请求操作系统服务）间接读取文件|

## 三、填空题（每空2分，共20分）

|题号|答案|解析|
|---|---|---|
|1|操作系统|操作系统是软件系统的核心，直接管理硬件资源、调度程序执行，决定计算机运算效率和软件运行效率|
|2|操作系统|操作系统是连接计算机硬件（底层）和应用软件（上层）的中间桥梁，提供统一的资源访问接口|
|3|a（或a+）|Python中open()函数的追加模式：`a`（仅追加写）、`a+`（读写+追加），均在文件尾部添加数据|
|4|True|逻辑运算规则：非0值视为True；not True=False，False or 1（True），最终结果为True|
|5|IEEE 754标准|现代计算机CPU处理浮点数均遵循IEEE 754标准，规定浮点数的存储格式、运算规则|
|6|IP地址（或IPv4/IPv6地址）|IP地址是计算机在网络中的唯一标识，用于跨网络数据传输时的目标定位|
|7|中断|现代操作系统采用“中断方式”管理硬件（硬件主动请求CPU处理），效率远高于早期“轮询方式”|
|8|溢出|无符号整数加法中，和的二进制位数超出CPU字长（如8位CPU计算255+2=257），称为溢出|
|9|HTML（超文本标记语言）|HTML是构建静态网页结构的核心语言，配合CSS实现样式美化，仅用于静态内容展示|

## 四、计算题（每小题3分，共15分）

### 1. 求十进制数（-6）的8位补码

#### 解题步骤：

1. **求绝对值的原码**：6的二进制为`110`，8位原码（正数符号位为0）为`00000110`。

2. **求负数的原码**：符号位改为1（表示负数），其余位不变，得`10000110`。

3. **求反码**：原码除符号位外，其余位按位取反，得`11111001`。

4. **求补码**：反码加1，得`11111010`。

#### 答案：`11111010`

### 2. 无符号二进制数(00110111)₂转换成八进制

#### 解题步骤：

1. **二进制分组**：八进制基数为8，从右往左每3位为一组（不足3位左侧补0），原二进制分组为`001 101 111`。

2. **分组转八进制**：每组3位二进制对应1位八进制：001=1，101=5，111=7。

3. **组合结果**：将各组结果拼接，得`157`。

#### 答案：`157`（或`157o`）

### 3. 十进制数16.2转换成二进制（保留4位小数）

#### 解题步骤：

1. **整数部分（16）转换**：除以2取余，从下往上排列：16÷2=8余0 → 8÷2=4余0 → 4÷2=2余0 → 2÷2=1余0 → 1÷2=0余1 → 整数部分`10000`。

2. **小数部分（0.2）转换**：乘2取整，保留4位小数：0.2×2=0.4（取整0）→ 0.4×2=0.8（取整0）→ 0.8×2=1.6（取整1）→ 0.6×2=1.2（取整1）→ 小数部分`0011`。

3. **组合结果**：整数部分+小数部分，得`10000.0011`。

#### 答案：`10000.0011`

### 4. 计算表达式`3%2//5`的值

#### 解题步骤：

1. **运算优先级**：`%`（取余）和`//`（整除）同级，从左到右计算。

2. **第一步取余**：3%2=1（3除以2的余数为1）。

3. **第二步整除**：1//5=0（1除以5的商整数部分为0）。

#### 答案：`0`

### 5. 计算表达式`5>6 and 12<3 or 8<9`的值

#### 解题步骤：

1. **运算优先级**：`<`>`>`高于`and`和`or`，先计算比较表达式：5>6=False，12<3=False，8<9=True。

2. **计算逻辑运算**：`and`优先级高于`or`，先算False and False=False，再算False or True=True。

#### 答案：`True`

## 五、简答题（每小题5分，共25分）

### 1. 进程的定义、组成及各部分作用

#### （1）进程定义

进程是操作系统进行**资源分配和调度的基本单位**，是正在运行的程序的实例（程序加载到内存后开始执行的状态）。

#### （2）进程的组成及作用

1. **程序段**：存储进程执行所需的指令集合（即运行的程序代码），是进程执行的逻辑基础。

2. **数据段**：存储进程执行时操作的原始数据、中间结果和最终结果（如变量、数组等）。

3. **进程控制块（PCB）**：核心管理部分，存储进程的状态（运行/就绪/阻塞）、PID（进程ID）、CPU寄存器值、内存地址等信息，操作系统通过PCB控制进程生命周期。

### 2. 冯·诺依曼体系结构计算机运行程序的过程（以`n=n+1`为例）

冯·诺依曼体系的核心是“存储程序+程序控制”，运行程序分为以下步骤：

1. **编译阶段**：高级语言代码`n=n+1`被编译器翻译成二进制机器指令，存储在硬盘可执行文件中。

2. **加载阶段**：操作系统将文件中的指令和变量`n`的数据加载到内存，为`n`分配固定内存地址（假设为`0x4000`）。

3. **指令周期（取指-译码-执行）**：

    - 取指：程序计数器（PC）指向`n=n+1`的指令地址，控制器从内存读出指令存入指令寄存器（IR）。

    - 译码：译码器解析指令为“从`0x4000`取`n`的值→加1→存回`0x4000`”。

    - 执行：运算器（ALU）从内存读出`n`的值存入通用寄存器，执行加1运算，再将结果写回内存`0x4000`。

4. **结束**：PC自动递增指向下一步指令，完成`n=n+1`的执行。

#### 汇编语言示例（简化）：

```
mov eax, [0x4000]  ; 取n的值到eax寄存器
add eax, 1         ; eax = eax + 1
mov [0x4000], eax  ; 结果存回内存，更新n
```

### 3. 递归函数及编程基本步骤

#### （1）递归函数定义

递归函数是**在函数体内直接或间接调用自身**的函数，核心思想是“将复杂问题分解为规模更小的同类子问题”，通过边界条件终止递归。

#### （2）编程基本步骤

1. **确定边界条件**：明确递归的终止条件（避免无限递归），如“求n^k时，k=1返回n”。

2. **推导递归公式**：建立原问题与子问题的关系，如“n^k = n × n^(k-1)”。

3. **实现递归调用**：在函数体内调用自身，传入规模更小的参数（如`pow(n, k-1)`）。

4. **返回结果**：将子问题的结果组合，返回原问题的解。

### 4. TCP/IP协议分层及各层功能（四层模型）

TCP/IP协议簇分为四层，从下到上依次为：

1. **网络接口层（链路层）**：底层，负责将数据封装为帧，实现数据在物理传输介质（网线、无线信号）上的传输，处理MAC地址和链路错误。

2. **网络层（互联层）**：核心层，通过IP地址标识设备，负责跨网络路由选择（确定数据传输路径）、数据分片与重组，核心协议为IP、ICMP。

3. **传输层**：端到端通信层，提供可靠/高效传输服务：

    - TCP：面向连接、可靠传输（差错重传、流量控制），适用于文件传输、网页访问。

    - UDP：无连接、高效传输，适用于视频通话、游戏。

4. **应用层**：顶层，为应用程序提供网络服务，核心协议有HTTP（网页）、FTP（文件传输）、SMTP（邮件）、DNS（域名解析）。

### 5. 中断的类型及举例

中断是硬件或软件向CPU发送的“处理请求”，使CPU暂停当前任务，优先处理紧急事务，分为两类：

#### （1）硬件中断（外部中断）

- 定义：由计算机外部硬件设备触发的中断。

- 举例：键盘输入中断（按键盘键）、鼠标点击中断、磁盘I/O中断（磁盘读写完成）、时钟中断（定时触发）。

#### （2）软件中断（内部中断/异常）

- 定义：由程序执行错误或主动请求触发的中断。

- 举例：系统调用（如文件读写、网络通信）、除0异常、内存访问越界、断点中断（程序调试）。

## 六、算法题（每小题5分，共10分）

### 1. 递归函数求解`n^k`（n和k为大于1的整数）

#### 解题思路：

- 边界条件：k=1时，n^1 = n（递归终止）。

- 递归公式：n^k = n × n^(k-1)（将k次幂分解为k-1次幂与n的乘积）。

#### 完整代码：

```Python
def power(n, k):
    # 边界条件：k=1时返回n
    if k == 1:
        return n
    # 递归调用：n^k = n * n^(k-1)
    return n * power(n, k-1)

# 函数外执行
n = int(input("请输入整数n（n>1）："))
k = int(input("请输入整数k（k>1）："))
print(f"{n}^{k} = {power(n, k)}")
```

#### 示例运行：

输入`n=3`、`k=4`，输出`3^4 = 81`；输入`n=2`、`k=5`，输出`2^5 = 32`。

### 2. 分治法查找无序整数列表中的最大值

#### 解题思路：

- 分治思想：将列表递归拆分为左右两半，分别查找每半的最大值，再比较两半最大值，得到整个列表的最大值。

- 边界条件：列表长度为1时，最大值为唯一元素。

#### 完整代码：

```Python
def find_max(lst):
    # 边界条件：列表只有1个元素，直接返回
    if len(lst) == 1:
        return lst[0]
    # 拆分列表为左右两半
    mid = len(lst) // 2
    left_max = find_max(lst[:mid])  # 左半部分最大值
    right_max = find_max(lst[mid:])  # 右半部分最大值
    # 比较两半最大值，返回更大值
    return left_max if left_max > right_max else right_max

# 函数外执行
lst = [5, 9, 3, 12, 7, 18, 4]
print(f"列表中的最大值为：{find_max(lst)}")
```

#### 示例运行：

输入列表`[5,9,3,12,7,18,4]`，输出`18`；输入列表`[23, 45, 11, 67, 8]`，输出`67`。
> （注：文档部分内容可能由 AI 生成）