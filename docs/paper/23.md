# 广东金融学院2023学年第1学期《计算机导论》A卷答案及解析

## 一、单项选择题（每小题1分，共20分）

|题号|答案|核心解析|相关知识点|
|---|---|---|---|
|1|D|程序计数器（PC）的功能是指向下一步要执行的指令地址；DR是数据寄存器（存储临时数据），IR是指令寄存器（存储当前指令），ALU是算术逻辑单元（执行运算）|CPU核心寄存器功能区分|
|2|C|输出设备的作用是将计算机处理结果反馈给用户，显示器符合；键盘、鼠标是输入设备，硬盘是存储设备|计算机硬件：输入/输出/存储设备区分|
|3|D|外存储器（如硬盘、U盘）的特点：存储速度比内存慢、成本更低、存储容量更大；内存（RAM）的特点是速度快、容量小、成本高|内存储器vs外存储器的特性对比|
|4|A|高级语言是接近人类自然语言的编程语言（如C++、Java、Python），汇编语言是直接面向硬件的低级语言（依赖CPU架构）|程序语言分类：低级vs高级|
|5|B|操作系统是系统软件的核心，负责管理**全部硬件资源**（CPU、内存、外存等）和**软件资源**（程序、数据、文档等），并非仅管理单一资源|操作系统的核心功能|
|6|B|有符号整数的符号位规则：0表示正数，1表示负数；-9是负数，故最高位（符号位）为1|有符号数的表示规则|
|7|B|队列的核心特性是“先进先出（FIFO）”，如同排队买票；栈是“先进后出（FILO）”，顺序存储/倒序存取是存储方式，非工作方式|数据结构：队列的存取规则|
|8|C|IPv4地址由32位二进制数组成，通过点分十进制拆分为4段（每段8位）；IPv6地址为128位|IP地址（IPv4）的结构|
|9|A|IP地址点分十进制的每段取值范围是0~255，192.168.0.258中258超出合法范围，其余选项均符合要求|IP地址的格式规范|
|10|D|Python函数的核心规则：①必须先定义后调用（A错误，支持嵌套调用；B错误，可无返回值（默认返回None）；C错误，局部变量在函数调用时存入进程栈）|Python函数的基本特性|
|11|B|栈“先进后出”特性：4、5、6依次入栈后，可能的出栈顺序：<br>- 4出→5出→6出（A）；6出→5出→4出（D）；5出→4出→6出（C）；<br>B选项6出后，栈内剩余4、5，只能5先出，无法4先出，故不可能|栈的存取规则应用|
|12|A|除0运算是程序运行时的“逻辑异常”（非硬件触发、非主动系统调用），会向操作系统发送异常处理请求；硬件中断由硬件触发，软件中断是主动请求（如系统调用）|异常与中断的区分|
|13|D|域名顶级域含义：.org（社会组织）、.com（商业机构）、.gov（政府机构）、.edu（教育机构）|域名系统（DNS）顶级域定义|
|14|B|计算机发展四代核心标志：①电子管（一代）→②晶体管（二代）→③中小规模集成电路（三代）→④大规模/超大规模集成电路（四代）|计算机发展历程|
|15|D|二进制转十六进制规则：从右往左每4位分组，1101=D，1011=B，故11011011=DB；A是十进制组合，B是十进制值，C多前导1|进制转换（二→十六）|
|16|A|冯·诺依曼体系结构（存储程序+程序控制）是现代计算机的基础；图灵是“计算机科学之父”，里奇发明C语言，香农是信息论之父|现代计算机核心体系结构|
|17|B|IR（Instruction Register）是指令寄存器，用于存储当前正在执行的指令；通用寄存器是灵活存储数据的寄存器，随机存储器（RAM）是内存，PC是程序计数器|CPU核心寄存器功能|
|18|B|算法复杂度的两大核心维度：时间复杂度（执行算法所需的时间资源）和空间复杂度（执行算法所需的内存资源）|算法复杂度的定义|
|19|A|break语句的唯一作用是**终止当前所在的循环**（for/while循环）；中断条件语句用elif，异常处理用try-except，终止函数执行用return|Python关键字（break）功能|
|20|A|网络协议是计算机网络中设备交换数据的“规则约定”（如TCP/IP、HTTP）；通道是数据传输路径，配置是设备参数设置，通信是数据交换行为|计算机网络基础：协议的定义|

## 二、判断题（每小题1分，共10分）

|题号|答案|解析|
|---|---|---|
|1|×|冯·诺依曼体系结构的计算机必须包含五大基本部件（运算器、控制器、存储器、输入设备、输出设备），输出设备是不可或缺的（需反馈处理结果）|
|2|×|汽车中的计算机（如发动机控制系统）是为特定任务设计的**专用计算机**，而非通用计算机（通用计算机可处理多种任务，如PC、笔记本）|
|3|√|有符号整数运算中，正整数与负数相加本质是“绝对值相减”，结果的绝对值不会超过任一操作数的绝对值，不会超出有符号数的取值范围（如8位补码-128~127），故不会溢出|
|4|×|CPU的核心功能包括**运算**（ALU执行算术/逻辑运算）和**控制**（协调各部件按指令顺序工作），并非仅用于计算|
|5|×|无符号数无需符号位，直接用二进制原码表示（数值本身），补码仅用于有符号数（简化减法运算、统一0的表示）|
|6|×|Python是动态类型语言，变量无需提前定义类型，直接赋值即可使用（如`a=10`直接创建变量a）|
|7|√|智能手机具备计算机的五大基本部件，是嵌入式计算机的一种，本质上属于计算机（可执行程序、处理数据）|
|8|√|现代操作系统管理硬件采用**中断方式**（硬件主动向CPU发送请求，效率高）；轮询方式（CPU循环查询硬件状态）仅用于早期简单系统|
|9|√|系统调用是应用程序向操作系统请求服务的接口（如文件读写、网络通信），由程序主动触发，属于**软件中断**（区别于硬件中断）|
|10|√|目前全球计算机网络通用的通信模型是**TCP/IP模型**；OSI模型是理论参考模型，未在实际中大规模应用|

## 三、填空题（每小题2分，共20分）

|题号|答案|解析|
|---|---|---|
|1|运算器（或ALU）；存储器|计算机硬件层的五大基本部件：控制器、运算器（ALU）、存储器、输入设备、输出设备|
|2|特权；非特权|操作系统的指令分为两类：特权指令（仅操作系统可执行，如修改内存管理寄存器）和非特权指令（用户程序可执行，如普通算术运算）|
|3|r+；w+（或a+，任填一个合理模式）|Python中open()函数的核心打开模式：r（只读）、r+（读写）、w（只写，覆盖文件）、a（追加写）、w+（读写，覆盖文件）、a+（读写，追加）|
|4|False|逻辑运算优先级：`not`>`and`；先算not True=False，再算False and 2<3（True），最终结果为False|
|5|有符号；无符号|计算机中的整数按是否需要表示正负，分为有符号整数（可表示正数、负数、0）和无符号整数（仅表示非负数）|
|6|应用|TCP/IP模型的应用层直接面向应用程序，提供端到端的通信服务（如HTTP用于网页访问，SMTP用于邮件发送），负责应用程序之间的通信|
|7|网络接口（或链路）|TCP/IP模型的网络接口层是底层，负责将数据封装为帧，实现数据在物理传输介质（如网线、无线信号）上的传输|
|8|加电自检（POST）；系统引导（Bootstrap）|计算机开机启动的三大阶段：①加电自检（检测硬件是否正常）→②系统引导（从BIOS/UEFI找到操作系统）→③启动加载（将操作系统加载到内存并运行）|
|9|补码|补码的优势：将减法转化为加法，0的表示唯一，是计算机中处理有符号数算术运算的标准方式|
|10|将寄存器R1的值与十六进制数0Ah（十进制10）相加，结果存回寄存器R1|汇编指令格式`add 目标寄存器, 源寄存器, 立即数`：目标寄存器存储运算结果，源寄存器是被操作数，立即数是固定值（0Ah=十进制10）|

## 四、计算题（每小题3分，共15分）

### 1. 求十进制数（-5）的8位补码

#### 解题步骤：

1. **求绝对值的原码**：5的二进制为`101`，8位原码（正数符号位为0）为`00000101`。

2. **求负数的原码**：符号位改为1（表示负数），其余位不变，得`10000101`。

3. **求反码**：原码除符号位外，其余位按位取反，得`11111010`。

4. **求补码**：反码加1，得`11111011`。

#### 答案：`11111011`

### 2. 无符号二进制数(11110001)₂转换成十六进制

#### 解题步骤：

1. **二进制分组**：从右往左每4位为一组（不足4位左侧补0，不影响值），原二进制分组为`1111 0001`。

2. **分组转十六进制**：4位二进制对应1位十六进制，1111=F，0001=1。

3. **组合结果**：将两组结果拼接，得`F1`。

#### 答案：`F1h`（或`F1`）

### 3. 十进制数123.456转换成二进制（保留4位小数）

#### 解题步骤：

1. **整数部分（123）转换**：除以2取余，从下往上排列：123÷2=61余1 → 61÷2=30余1 → 30÷2=15余0 → 15÷2=7余1 → 7÷2=3余1 → 3÷2=1余1 → 1÷2=0余1 → 整数部分`1111011`。

2. **小数部分（0.456）转换**：乘2取整，保留4位小数：0.456×2=0.912（取整0）→ 0.912×2=1.824（取整1）→ 0.824×2=1.648（取整1）→ 0.648×2=1.296（取整1）→ 小数部分`0111`。

3. **组合结果**：整数部分+小数部分，得`1111011.0111`。

#### 答案：`1111011.0111`

### 4. 计算表达式`45//5%2`的值

#### 解题步骤：

1. **运算优先级**：`//`（整除）和`%`（取余）同级，从左到右计算。

2. **第一步整除**：45//5=9（整除取商的整数部分）。

3. **第二步取余**：9%2=1（9除以2的余数为1）。

#### 答案：`1`

### 5. 计算表达式`5<6 and 12>3 and 8>9`的值

#### 解题步骤：

1. **逻辑运算优先级**：`<`>`>`高于`and`，先计算每个比较表达式：5<6=True，12>3=True，8>9=False。

2. **计算** **`and`** **运算**：`and`是“全真才真”，True and True and False=False。

#### 答案：`False`

## 五、简答题（每小题5分，共25分）

### 1. 多道进程系统中操作系统对CPU的调度管理（含图）

#### （1）核心目标

在多道程序环境中，合理分配CPU资源，提高CPU利用率，实现进程并发执行。

#### （2）调度相关概念

- **就绪队列**：所有已具备运行条件（等待CPU）的进程集合。

- **运行态**：占用CPU执行指令的进程状态。

- **阻塞队列**：因等待资源（如I/O、信号量）而暂停运行的进程集合。

- **调度算法**：常用算法有FCFS（先来先服务）、优先级调度、时间片轮转调度。

#### （3）调度流程

1. 进程创建后进入就绪队列，等待CPU调度。

2. 操作系统通过调度算法从就绪队列选择一个进程，分配CPU，使其从就绪态转为运行态。

3. 若进程时间片用完或有更高优先级进程进入就绪队列，当前进程退回就绪队列。

4. 若进程请求I/O等资源，转为阻塞态，等待资源到位后被唤醒，重新进入就绪队列。

5. 进程执行完成后退出系统。

#### （4）调度管理示意图

```Plain Text
┌─────────────┐        调度算法        ┌─────────────┐
│  就绪队列   ├────────────────────────→│  运行态进程 │
└─────────────┘                        └─────────────┘
        ↑                                  ↓
        │ 资源到位（唤醒）                  │ 时间片用完/高优先级进程进入
        │                                  │ 或请求资源（I/O等）
        └──────────────────────────────────┘
                ┌─────────────┐
                │  阻塞队列   │
                └─────────────┘
```

### 2. 以`a=a+1`为例，程序执行过程

#### 核心逻辑：程序执行是“存储程序+指令周期（取指-译码-执行）”的循环，涉及内存、CPU、总线的协作。

#### 步骤分解：

1. **编译阶段**：高级语言代码`a=a+1`被编译器翻译成机器语言指令（二进制），存储在硬盘的可执行文件中。

2. **加载阶段**：操作系统将可执行文件中的指令和变量`a`的数据加载到内存，为`a`分配固定内存地址（假设为`0x3000`）。

3. **指令周期执行**：

    - 取指：程序计数器（PC）指向`a=a+1`的指令地址，控制器通过地址总线找到该指令，从内存读出并存入指令寄存器（IR）。

    - 译码：译码器解析IR中的指令，确定操作是“从内存`0x3000`取数→加1→存回`0x3000`”。

    - 执行：① ALU通过数据总线从内存`0x3000`读出`a`的值，存入通用寄存器；② ALU执行“加1”运算；③ 运算结果通过数据总线写回内存`0x3000`，`a`的值更新。

4. **结束**：PC自动递增，指向下一步指令，完成`a=a+1`的执行。

#### 汇编语言示例（简化）：

```
mov eax, [0x3000]  ; 从内存0x3000取a的值到eax寄存器
add eax, 1         ; eax = eax + 1（执行a+1）
mov [0x3000], eax  ; 将结果存回内存0x3000，更新a的值
```

### 3. 递归函数及编程基本步骤

#### （1）递归函数定义

递归函数是**在函数体内直接或间接调用自身**的函数，核心思想是“将复杂问题分解为规模更小的同类子问题”，最终通过边界条件终止递归。

#### （2）编程基本步骤

1. **确定边界条件（终止条件）**：明确递归何时停止（避免无限递归），如“斐波那契数列第1项为0，第2项为1”。

2. **推导递归公式**：将原问题分解为规模更小的子问题，建立原问题与子问题的关系，如“斐波那契第n项=第n-1项+第n-2项”。

3. **实现递归调用**：在函数体内调用自身，传入规模更小的参数（如子问题的输入）。

4. **返回结果**：将子问题的结果组合，返回原问题的解。

#### 示例：求n的阶乘（递归函数）

```Python
def fact(n):
    if n == 1:  # 边界条件
        return 1
    return n * fact(n-1)  # 递归公式+递归调用
```

### 4. TCP/IP协议中网络层的作用

TCP/IP协议的网络层（又称互联层）是核心中间层，连接传输层和网络接口层，主要作用如下：

1. **IP寻址**：为网络中的每台设备分配唯一的IPv4/IPv6地址，标识设备的网络位置（如[192.168.1.1](192.168.1.1)）。

2. **路由选择**：通过路由协议（如RIP、OSPF）确定数据从源设备到目标设备的最佳传输路径（跨越不同网络时）。

3. **数据分片与重组**：当数据报大小超过传输介质的MTU（最大传输单元）时，网络层将数据报分片传输，目标设备收到后重组为完整数据报。

4. **差错控制与报告**：通过ICMP（互联网控制消息协议）检测网络故障（如目标不可达、超时），并向源设备发送差错报告。

5. **网络互联**：屏蔽底层物理网络的差异（如以太网、无线局域网），实现不同类型网络的互联互通。

### 5. 现代计算机系统中操作系统的作用

操作系统是硬件与用户之间的桥梁，核心作用包括以下5点：

1. **资源管理**：管理计算机全部硬件资源（CPU、内存、外存、设备）和软件资源（程序、数据），合理分配资源，避免冲突。

2. **进程管理**：负责进程的创建、调度、终止，实现进程并发执行，提高CPU利用率。

3. **设备管理**：通过设备驱动程序管理输入/输出设备（如键盘、显示器、打印机），为用户程序提供统一的设备访问接口（屏蔽硬件差异）。

4. **文件管理**：管理外存中的文件和目录，提供文件的创建、读取、修改、删除等操作，维护文件的安全性和完整性。

5. **用户接口**：为用户提供与计算机交互的方式，包括命令行接口（如CMD、Terminal）、图形用户接口（如Windows桌面、macOS）和程序接口（系统调用，供应用程序调用OS服务）。

## 六、算法题（每小题5分，共10分）

### 1. 递归算法生成前n项斐波拉契数列（列表存储）

#### 解题思路：

- 边界条件：n=1时返回[0]，n=2时返回[0,1]。

- 递归公式：前n项斐波拉契数列=前n-1项数列+[前n-1项最后两项之和]。

#### 完整代码：

```Python
def fibonacci(n):
    if n == 1:
        return [0]  # 边界条件1：前1项为[0]
    elif n == 2:
        return [0, 1]  # 边界条件2：前2项为[0,1]
    else:
        # 递归调用：前n项 = 前n-1项 + [第n项（前n-1项最后两项之和）]
        prev_list = fibonacci(n-1)
        next_num = prev_list[-1] + prev_list[-2]
        return prev_list + [next_num]

# 函数外执行
n = int(input("请输入斐波拉契数列的项数："))
print(fibonacci(n))
```

#### 示例运行：

输入`5`，输出`[0, 1, 1, 2, 3]`；输入`8`，输出`[0, 1, 1, 2, 3, 5, 8, 13]`。

### 2. 二分法查找有序整数列表中元素x的索引

#### 解题思路：

- 前提：列表已升序排列。

- 核心：通过不断缩小查找范围（中间元素为分界），快速定位目标元素。

- 步骤：初始化左右边界→计算中间索引→比较中间元素与x→调整边界→重复直至找到。

#### 完整代码：

```Python
def binary_search(L, x):
    left = 0  # 左边界索引
    right = len(L) - 1  # 右边界索引
    while left <= right:
        mid = (left + right) // 2  # 中间索引（避免溢出）
        if L[mid] == x:
            return mid  # 找到目标，返回索引
        elif L[mid] < x:
            left = mid + 1  # x在右半部分，调整左边界
        else:
            right = mid - 1  # x在左半部分，调整右边界
    return -1  # 未找到（题目要求“不用考虑找不到”，可省略此句）

# 函数外执行
L = [12, 23, 34, 45, 56, 67, 78, 89]  # 升序列表
x = int(input("请输入要查找的整数："))
print(f"元素{x}的索引为：{binary_search(L, x)}")
```

#### 示例运行：

输入`45`，输出`3`；输入`67`，输出`5`。
> （注：文档部分内容可能由 AI 生成）